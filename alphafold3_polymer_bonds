#!/usr/bin/env python3
"""
Protein Bond Modeling Script

This script processes AlphaFold3 JSON files to model protein-protein bonds 
using ligand bridges. It identifies bonds between protein chains and modifies 
the structure to represent these bonds through intermediate ligand molecules.

The algorithm works by:
1. Identifying protein-protein bonds from bondedAtomPairs
2. Converting one of the bonded amino acids into a ligand molecule
3. Splitting the original chain and creating new chain segments
4. Establishing bonds through the ligand as an intermediate bridge

This approach allows modeling of complex protein interactions while maintaining
proper chemical connectivity through ligand intermediates.

Usage:
    ./alphafold3_polymer_bonds --source-dir input/ --output-dir output/
    ./alphafold3_polymer_bonds -s input/ -o output/ --verbose

Authors: Ricardo Heinzmann, Jürgen Jänes
"""

import argparse, json, string, sys

from copy import deepcopy
from pathlib import Path
from pprint import pprint

from typing import Dict, List, Tuple, Any, TypeAlias
JSON: TypeAlias = dict[str, "JSON"] | list["JSON"] | str | int | float | bool | None #https://github.com/python/typing/issues/182#issuecomment-1320974824

from pandas import DataFrame, option_context as pd_option_context

poly_to_ligand = {
    'protein': {
        'G': 'GLY', 'A': 'ALA', 'V': 'VAL', 'L': 'LEU', 'I': 'ILE',
        'P': 'PRO', 'F': 'PHE', 'Y': 'TYR', 'W': 'TRP', 'S': 'SER',
        'T': 'THR', 'C': 'CYS', 'M': 'MET', 'N': 'ASN', 'Q': 'GLN',
        'D': 'ASP', 'E': 'GLU', 'K': 'LYS', 'R': 'ARG', 'H': 'HIS'
    },
    'dna': {
        'A': 'DA',
        'G': 'DG',
        'C': 'DC',
        'T': 'DT',
    },
    'rna': {
        'A': 'A',
        'C': 'C',
        'G': 'G',
        'U': 'U',
    },
}

def generate_residue_mapping(json_data: JSON) -> DataFrame:
    """
    Generate mapping from input .json with polymer bonds by modelling the second entity in bondedAtomPairs as a ligand.

    Args:
        - json_data AlphaFold3 input with polymer bonds in bondedAtomPairs

    Returns:
        DataFrame wit following columns:
        - id, modified_id
        - pos, modified_pos
        - type, modified_type
    """
    columns_ = ['type', 'id', 'seq']
    df_ = DataFrame.from_records([(next(iter(seq.keys())), next(iter(seq.values()))['id'], next(iter(seq.values()))['sequence']) \
        for seq in json_data['sequences']], columns=columns_)
    df_['seq'] = df_['seq'].map(list)
    df_['pos'] = df_['seq'].map(lambda seq: range(1, len(seq) + 1))

    df_ = df_.explode(['seq', 'pos']).set_index(['id', 'pos'])
    columns_ = ['id1', 'pos1', 'atom1', 'id2', 'pos2', 'atom2']
    bondedAtomPairs_ = json_data['bondedAtomPairs'] if 'bondedAtomPairs' in json_data else []
    bondedAtomPairs = DataFrame.from_records([ 
        (pair_[0][0], pair_[0][1], pair_[0][2], pair_[1][0], pair_[1][1], pair_[1][2]) for pair_ in bondedAtomPairs_], columns=columns_)

    df_['modified_type'] = df_['type']
    for i, r in bondedAtomPairs.iterrows():
        type1 = df_.loc[(r.id1, r.pos1), 'type']
        type2 = df_.loc[(r.id2, r.pos2), 'type']
        print(r.id1, r.pos1, r.id2, r.pos2, type1, type2)
        if (type1 != 'ligand') and (type2 != 'ligand'):
            df_.loc[(r.id2, r.pos2), 'modified_type'] = 'ligand'

    df_['modified_seq'] = df_['seq']
    for i, r in df_.iterrows():
        if r.type != 'ligand' and r.modified_type == 'ligand':
            df_.loc[i, 'modified_seq'] = poly_to_ligand[r.type][r.seq]

    id_prefix = iter(string.ascii_uppercase)
    df_['modified_id'] = ''
    for (i1, r1), (i2, r2) in zip(df_.iterrows(), df_.iloc[1:].iterrows()):
        if i1[0] != i2[0]: # new chain
            id_prefix = iter(string.ascii_uppercase)
            df_.loc[i2, 'modified_id'] = ''
        elif i1[0] == i2[0] and r1.modified_type != r2.modified_type: # ligand transformation
            df_.loc[i2, 'modified_id'] = next(id_prefix)
        else: # walking along existing chain
            df_.loc[i2, 'modified_id'] = df_.loc[i1, 'modified_id']            
    df_['modified_id'] = df_.index.get_level_values('id') + df_['modified_id']
    df_['modified_pos'] = df_.groupby(['modified_id', 'modified_type']).cumcount() + 1

    cols_ = ['id', 'pos', 'type', 'seq', 'modified_id', 'modified_pos', 'modified_type', 'modified_seq']
    return df_.reset_index()[cols_].set_index(['id', 'pos'])

def generate_modified_json(json_data: JSON, mapping: DataFrame) -> JSON:
    """
    Modify json_data based on the specified residue mapping
    """

    modified_json = deepcopy(json_data)
    # TODO - ordering does not match what's in original file (can infer from json_data)
    sequences = mapping.groupby('modified_id').agg(
        modified_type=('modified_type', lambda x: x.iloc[0]),
        modified_seq=('modified_seq', lambda x: ''.join(x)),
    ).reset_index()

    modified_json['sequences'] = []
    for i, r in sequences.iterrows():
        if r.modified_type == 'ligand':
            modified_json['sequences'].append({
                'ligand': {
                    'id': r.modified_id,
                    'ccdCodes': [ r.modified_seq ],
            }})
        else:
            modified_json['sequences'].append({
            r.modified_type: {
                'id': r.modified_id,
                'sequence': r.modified_seq,
            }})

    modified_json['bondedAtomPairs'] = []
    bondedAtomPairs_ = json_data['bondedAtomPairs'] if 'bondedAtomPairs' in json_data else []
    for ((id1, pos1, atom1), (id2, pos2, atom2)) in bondedAtomPairs_:
        # Add preceding protein backbone bond 
        if mapping.loc[(id2, pos2), 'type'] == 'protein' and mapping.loc[(id2, pos2), 'modified_type'] == 'ligand':
            modified_json['bondedAtomPairs'].append([
                (mapping.loc[(id2, pos2 - 1), 'modified_id'], int(mapping.loc[(id2, pos2 - 1), 'modified_pos']), 'C'),
                (mapping.loc[(id2, pos2), 'modified_id'], int(mapping.loc[(id2, pos2), 'modified_pos']), 'N'),
            ])

        # Update all coordinates to new mapping
        modified_json['bondedAtomPairs'].append([
            (mapping.loc[(id1, pos1), 'modified_id'], int(mapping.loc[(id1, pos1), 'modified_pos']), atom1),
            (mapping.loc[(id2, pos2), 'modified_id'], int(mapping.loc[(id2, pos2), 'modified_pos']), atom2),
        ])

        # Add succeeding protein backbone bond
        if mapping.loc[(id2, pos2), 'type'] == 'protein' and mapping.loc[(id2, pos2), 'modified_type'] == 'ligand':
            modified_json['bondedAtomPairs'].append([
                (mapping.loc[(id2, pos2), 'modified_id'], int(mapping.loc[(id2, pos2), 'modified_pos']), 'C'),
                (mapping.loc[(id2, pos2 + 1), 'modified_id'], int(mapping.loc[(id2, pos2 + 1), 'modified_pos']), 'N'),
            ])

    return modified_json

def process_json_files(source_path: Path, output_path: Path, mapping_path: Path = None) -> None:
    """
    Process all JSON files in the source directory and create modified versions.
    Optionally saves the final residue mapping for each file if residue_mapping_dir is specified.
    
    Args:
        source_path: Directory containing original JSON files
        output_path: Directory to save modified JSON files
        mapping_path: Directory to save residue mapping JSON files (optional)
    """
    # Create output directory
    output_path.mkdir(parents=True, exist_ok=True)
    if mapping_path:
        mapping_path.mkdir(parents=True, exist_ok=True)

    # Process files
    for json_path in source_path.glob('*.json'):
        try:
            with open(json_path, 'r') as fh:
                json_data = json.load(fh)
            print(f"Loaded: {json_path.name}")
        except Exception as e:
            print(f"Error loading {json_path.name}: {e}")

        # Generate mapping
        print(f"Processing {json_path.name}...")
        residue_mapping = generate_residue_mapping(json_data)

        # Use mapping to generate modified json and write to file
        modified_json = generate_modified_json(json_data, residue_mapping)
        modified_json_path = output_path / json_path.name
        with open(modified_json_path, 'w') as f:
            json.dump(modified_json, f, indent=2)
        print(f"Saved modified file: {modified_json_path}")

        # Write mapping
        if mapping_path:
            tsv_mapping_path = mapping_path / json_path.with_suffix('.tsv').name
            print(json_path.with_suffix('.tsv').name)
            print(tsv_mapping_path)
            residue_mapping.to_csv(tsv_mapping_path, sep='\t')
            print(f"Saved residue mapping: {tsv_mapping_path}")

def main():
    """
    Main function to execute the protein bond modeling script.
    """
    parser = argparse.ArgumentParser(
        description="Model protein-protein bonds using ligand bridges in AlphaFold3 JSON files"
    )
    parser.add_argument(
        "--source_dir", 
        "-s", 
        default="input/",
        help="Directory containing input JSON files (default: input/)"
    )
    parser.add_argument(
        "--output_dir", 
        "-o", 
        default="output/",
        help="Directory to save modified JSON files (default: output/)"
    )
    parser.add_argument(
        "--mapping_dir",
        default=None,
        help="Directory to save residue mapping JSON files (optional)"
    )
    
    args = parser.parse_args()
    
    print("Starting protein bond modeling process...")
    print(f"Source directory: {args.source_dir}")
    print(f"Output directory: {args.output_dir}")
    if args.mapping_dir:
        print(f"Residue mapping directory: {args.mapping_dir}")
    
    # Check if source directory exists
    if not Path(args.source_dir).exists():
        print(f"Error: Source directory '{args.source_dir}' does not exist!")
        return 1
    
    # Process all JSON files
    process_json_files(Path(args.source_dir), Path(args.output_dir), Path(args.mapping_dir))
    print("Process completed successfully!")
    return 0

if __name__ == "__main__":
    exit_code = main()
    exit(exit_code)
